<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
	"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>

	<title>Ding: Beans, IoC, DI, AOP</title>
	
	<style type="text/css">
		body {
  		margin-top: 1.0em;
  		background-color: #f49648;
		  font-family: "Helvetica,Arial,FreeSans";
  		color: #000000;
    }
    #container {
      margin: 0 auto;
      width: 700px;
    }
		h1 { font-size: 3.8em; color: #0b69b7; margin-bottom: 3px; }
		h1 .small { font-size: 0.4em; }
		h1 a { text-decoration: none }
		h2 { font-size: 1.5em; color: #0b69b7; }
    h3 { color: #0b69b7; }
    a { color: #0b69b7; }
    .description { font-size: 1.2em; margin-bottom: 30px; margin-top: 30px; font-style: italic;}
    .download { float: right; }
		pre { background: #000; color: #fff; padding: 15px;}
    hr { border: 0; width: 80%; border-bottom: 1px solid #aaa}
    .footer { text-align:center; padding-top:30px; font-style: italic; }
	</style>
	
</head>

<body>

<H1><u>Container, Inversion of Control, and Dependency Injection</u></H1><br/>
<H2><u>Beans</u></H2>
A Bean is just an object. We call it bean because this particular object obeys some
rules and this rules and the bean's lifecycle are managed entirely by what is called
a container.<br/> 
In the java world, a bean is a POJO (Plan Old Java Object), meaning that
virtually any concrete class definition is a bean. Since the latter also
applies in the php world, we should say that a bean is a "POPO"
(Plain Old PHP Object).

<H3><u>Scopes</u></H3>
The scope of the bean defines its lifecycle (when it is created and when should
be destroyed). The container provides the following options as scopes:
<ul>
  <li><u>Singleton:</u>The container will have a single instance for the bean
  (lazy created), and will return this instance every time this bean is
  asked for.
  </li>
  <li><u>Prototype:</u>The container will return a new instance every time
  this bean is asked for.
  </li>
</ul>

<H3><u>Bean metadata</u></H3>
<p>
For each managed bean by the container, exists a bean definition, which 
composes all the metadata needed by the container and its extensions to
actually create and modify the bean's behavior.
</p>
<p>
This data is generated, and
modified by "Drivers". Drivers are listeners of one or more events in the lifecycle
of the container and the lifecycle of each bean. Currently, Ding supports 2 
different drivers: "xml" and "annotations".
</p>
<p>
The first one reads and parses a xml
file (normally called beans.xml) and the latter generates metadata from the annotations
found in each of the classes of the project and their methods.
</p>
<p>
 Any number of drivers can be used at any
given time, they are supposed to complement each one's metadata. So for example you may
use an annotation in your class at the same time that is declared (with the same or
different features or properties) in the beans.xml file.
</p>
This metadata includes:

<ul>
  <li><u>Properties:</u>Optional. Properties have also its own metadata (see below).</li>
  <li><u>Constructor arguments:</u>Optional. They almost identical to properties, and have
  their own metadata (see below).</li>
  <li><u>Aspects:</u>Optional. All aspects applied to this bean. Aspects have their own
  metadata (see below).</li>
  <li><u>Name:</u>Mandatory. The bean's name.</li>
  <li><u>Class:</u>Mandatory. The bean's full class name (including namespace, like A\B\Foo.</li>
  <li><u>Scope:</u>Mandatory. The bean's scope. This informs the container how to handle
  the lifecycle of this bean.</li>
  <li><u>Annotations:</u>Optional. All class-level annotations. Annotations have their
  own metadata. (see below).</li>
  <li><u>Init method:</u>Optional. You may declare an optional method to call right after the bean
  is constructed and its properties injected so you can initialize internal stuff.</li>
  <li><u>Shutdown method</u>Optional. You may declare an optional method to call when the container
  is destroyed, so you can cleanup internal stuff.</li>
  <li><u>Method annotations:</u>Optional. All method-level annotations.</li>
  <li><u>Bean dependencies:</u>Optional. Which beans need to be created before creating
  this bean. This has nothing to do with properties that reference other beans
  (those are resolved when creating each property), but with indirect
  dependencies (for instance, bean A depends on bean B which in turns depends
  on bean C, so in order to create bean A, we need to create C and B).</li>
  <li><u>Factory Method:</u>Optional. If specified, will call a static method of Factory
  Class, a method of Factory Method, or a static method of the bean class in
  order to create the bean (instead of using the constructor).</li>
  <li><u>Factory Class:</u>Optional. If specified, informs the container to call
  a static method (see Factory Method) of the given class to create the bean
  instead of using the constructor.</li>
  <li><u>Factory Bean:</u>Optional. Same as factory class, but will use a method for 
  the given bean.</li> 
</ul>

<H4><u>Examples:</u></H4>
<u>Generic bean definition (annotations driver)</u>
<p>
This is pretty much the same as Java Configuration. You can define a class and
annotate it with @Configuration. All methods of this class (or classes) annotated
themselves with @Bean will became a source for bean definitions.
</p>
<p>
@Configuration classes become factory beans. So, a class annotated with
@Configuration, having a method called "someBean" which is in turn annotated
with @Bean, will become the factory bean and factory method for the bean named
"someBean". See docs/examples/ConfigurationAnnotation.
</p>
<p>
This behavior can be overriden if you use the argument name= in the @Bean
annotation, like:<br/>
<br/>
@Bean(name=someOtherName)<br/><br/>
The string "someOtherName" is now the final name of the bean (although the method
is still used as the factory method).
</p>
<p>
For every of the @Bean annotated methods, you should also specify:
</p>
<p>
@Scope(value=xxx) Where xxx is one of prototype or singleton.
</p>
<p>
@InitMethod(method=xxx) Where xxx is the method to call to initialize the bean.
</p>
<p>
@DestroyMethod(method=xxx) Where xxx is the method to call to destroy the bean on
container shutdown.
</p>
<p>
/**<br/>
 * @Configuration<br/>
 */<br/>
class SomeBeanProviderClass<br/>
{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;/**<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* @Bean<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* @Scope(value='singleton')<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* @InitMethod(method=aMethod)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* @DestroyMethod(method=bMethod)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/<br/>
&nbsp;&nbsp;&nbsp;&nbsp;public function someBean()<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$ret = new MyBean();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$ret->setSomeProperty('hello world');<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return $ret;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;/**<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* @Bean(name=anOverridenName)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* @Scope(value='singleton')<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* @InitMethod(method=aMethod)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* @DestroyMethod(method=bMethod)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/<br/>
&nbsp;&nbsp;&nbsp;&nbsp;public function aNormalMethod()<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$ret = new MyBean();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$ret->setSomeProperty('hello world');<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return $ret;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
}<br/>
</p>
<u>Generic bean definition (xml driver)</u>
<p>
For a prototype bean (multiple instances allowed):<br/>
&lt;beans&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;bean id="beanName" class="A\B\C" scope="prototype"/&gt;<br/>
&lt;/beans&gt;<br/>
</p>
<hr/>
<p>
For a singleton bean (only one instance allowed):<br/>
&lt;beans&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;bean id="beanName" class="A\B\C" scope="singleton"/&gt;<br/>
&lt;/beans&gt;<br/>
</p>
All options in the above examples are *MANDATORY*. What follows are examples with
optional arguments:
<hr/>
<p>
This one will first create aBean, bBean, cBean before creating "beanName":<br/>
&lt;beans&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;bean id="beanName" class="A\B\C" scope="prototype" depends-on="aBean, bBean, cBean"/&gt;<br/>
&lt;/beans&gt;<br/>
</p>
<hr/>
<p>
This one will call A\B\C::getInstance() (static method) in order to get a bean:<br/>
&lt;beans&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;bean id="beanName" class="A\B\C" scope="prototype" factory-method="getInstance"/&gt;<br/>
&lt;/beans&gt;<br/>
</p>
<hr/>
<p>
This one will call AnotherClass::getInstance() (static method) in order to get a bean:<br/>
&lt;beans&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;bean id="beanName" class="A\B\C" scope="prototype" factory-class="AnotherClass" factory-method="getInstance"/&gt;<br/>
&lt;/beans&gt;<br/>
</p>
<hr/>
<p>
This one will first create "anotherBean" and then call anotherBean->getInstance() (instance method) in order to get the other bean:<br/>
&lt;beans&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;bean id="beanName" class="A\B\C" scope="prototype" factory-bean="anotherBean" factory-method="getInstance"/&gt;<br/>
&lt;/beans&gt;<br/>
</p>
<hr/>
<p>
This one will call init() as soon as the bean is created and all its properties are injected but before returning the instance to the caller:<br/>
&lt;beans&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;bean id="beanName" class="A\B\C" scope="prototype" init-method="init"/&gt;<br/>
&lt;/beans&gt;<br/>
</p>
<hr/>
<p>
This one will call destroy() when the container is destroyed:<br/>
&lt;beans&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;bean id="beanName" class="A\B\C" scope="prototype" destroy-method="destroy"/&gt;<br/>
&lt;/beans&gt;<br/>
</p>
<hr/>
<H3><u>Constructor arguments types and metadata</u></H3>
The constructor arguments for a bean behave exactly like properties. See the
sections below.
 
<H3><u>Properties types</u></H3>
<ul>
  <li><u>Array:</u>An array has a key (mandatory) and 1 value per key (which in
  turn can be of any type, so you can have arrays inside arrays, etc).</li>
  <li><u>Scalar value:</u>A final value, like a string, an integer, etc.</li>
  <li><u>Bean reference:</u>A string containing the name of another bean defined
  in the container.</li>
  <li><u>Code:</u>PHP code to be eval()'uated by the container.</li>
</ul>

<H3><u>Properties metadata</u></H3>
<ul>
  <li><u>Name:</u>The name of the property. The name is important for setter
injection, i.e: a property called 'name' will be injected calling setName()</li>
  <li><u>Type:</u>See above for properties types</li>
  <li><u>Value:</u>The actual value, whatever the type. The value can also be
  a string like ${some.value}, which resembles java properties. The container will
  notice this and will put the correct value (assuming you passed the right value
  when instantiating the container).</li>
</ul>
<p>
The value for the properties is run through a chain of filters. One of these filters
is PropertyFilter, responsible for replacing the ${property} kind of values.
</p>
<H4><u>Examples:</u></H4>
<p>
Define a scalar property:<br/>
&lt;beans&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;bean id="beanName" class="A\B\C" scope="prototype"&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;property name="someProperty"&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;value&gt;aValue&lt;/value&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/property&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;/bean&gt;<br/>
&lt;/beans&gt;<br/>
</p>
<hr/>
<p>
Define a scalar constructor argument:<br/>
&lt;beans&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;bean id="beanName" class="A\B\C" scope="prototype"&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;constructor-arg&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;value&gt;aValue&lt;/value&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/constructor-arg&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;/bean&gt;<br/>
&lt;/beans&gt;<br/>
</p>
<hr/>
<p>
Mixing both:<br/>
&lt;beans&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;bean id="beanName" class="A\B\C" scope="prototype"&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;constructor-arg&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;value&gt;aValue&lt;/value&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/constructor-arg&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;property name="someProperty"&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;value&gt;aValue&lt;/value&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/property&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;/bean&gt;<br/>
&lt;/beans&gt;<br/>
</p>
<hr/>
<H4>The following examples also apply to constructor arguments</H4>
<p>
Define a scalar property with a container property:<br/>
&lt;beans&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;bean id="beanName" class="A\B\C" scope="prototype"&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;property name="someProperty"&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;value&gt;${some.value}&lt;/value&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/property&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;/bean&gt;<br/>
&lt;/beans&gt;<br/>
</p>
<hr/>
<p>
Define a reference to another bean as a property:<br/>
&lt;beans&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;bean id="beanName" class="A\B\C" scope="prototype"&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;property name="someProperty"&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;ref bean="otherBean"/&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/property&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;/bean&gt;<br/>
&lt;/beans&gt;<br/>
</p>
<hr/>
<p>
Define a property as code to be evaluated:<br/>
&lt;beans&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;bean id="beanName" class="A\B\C" scope="prototype"&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;property name="someProperty"&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;eval&gt;&lt;![CDATA[ return "Some evaluated code"; ]]>&lt;/eval&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/property&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;/bean&gt;<br/>
&lt;/beans&gt;<br/>
</p>
<hr/>
<p>
Define an array as a property:<br/>
&lt;beans&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;bean id="beanName" class="A\B\C" scope="prototype"&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;property name="someProperty"&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;array&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;entry key="0"&gt;&lt;ref bean="otherBean"/&gt;&lt;/entry&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;entry key="1"&gt;&lt;value&gt;aValue&lt;/value&gt;&lt;/entry&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;entry key="2"&gt;&lt;eval&gt;&lt;![CDATA[ return "Some evaluated code"; ]]>&lt;/eval&gt;&lt;/entry&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;entry key="3"&gt;&lt;array&gt;&lt;entry key="other"&gt;&lt;value&gt;${aValue}&lt;/value&gt;&lt;/entry&gt;&lt;/array&gt;&lt;/entry&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/array&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/property&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;/bean&gt;<br/>
&lt;/beans&gt;<br/>
</p>
<hr/>
<H3><u>Annotations metadata</u></H3>
<ul>
  <li><u>Name:</u>The name of the annotation (i.e: @InitMethod).
  <li><u>Arguments:</u>The annotations arguments. For example @InitMethod(method=xxx)
  will result in an annotation named InitMethod with an argument 'method' having the
  value 'xxx'.</li>
</ul>


<H2><u>Container</u></H2>

The container is a factory of beans. It constructs an instance of a bean using the
metadata associated with it (and its subparts, like properties, annotations, etc).

<H3><u>Container managed annotations</u></H3>
<ul>
  <li><u>@InitMethod</u>: Has the same effect as declaring a bean with init-method in the beans.xml file.</li>
  <li><u>@DestroyMethod</u>: Has the same effect as declaring a bean with destroy-method in the beans.xml file.</li>
</ul>


<H3><u>Extension points</u></H3>

If you're wondering about how to extend Ding with different or new features,
there are some predefined "kind" of extension points:

<ul>
  <li>Drivers</li>
  <li>Filters</li>
  <li>Helpers</li>
</ul>

<H3><u>Drivers</u></H3>
Drivers are normal "lifecyclers". These can be any object that implements
ILifecycleListener and listens on one or more of the container lifecycle events:

<ul>
  <li>BeforeConfig</li>
  <li>AfterConfig</li> 
  <li>BeforeDefinition</li>
  <li>AfterDefinition</li>
  <li>BeforeCreate</li>
  <li>AfterCreate</li>
  <li>BeforeAssembly</li>
  <li>AfterAssembly</li>
</ul>
These classes usually reside in the namespace Ding\Bean\Factory\Driver.

Each lifecycle event triggers a chain of the lifecyclers for that particular
event, so the order might be important. The chain cant be interrupted.


<H3><u>Filters</u></H3>

Filters are used to transform a value of a property or constructor argument.
For example, PropertyFilter searches for the ${xxx} syntax 

in a property value and tries to replace it with a property named xxx.

Filters are chained and the chain cant be interrumpted.

<H3><u>Helpers</u></H3>
Helpers reside in the namespace Ding\Helpers. The helpers are usually normal
beans, lets call them "user space" code (meaning that they 

are not part of Ding's architecture per se, unlike Drivers and Filters that are
active players in the bean creation process).

<H3><u>ReflectionFactory</u></H3>
The namespace Ding\Reflection contains ReflectionFactory. This factory is
used throughout the container and its extension points 

</body>
</html>