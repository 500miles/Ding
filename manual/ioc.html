<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
	"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>

	<title>Ding: Beans, IoC, DI, AOP</title>
	
	<style type="text/css">
		body {
  		margin-top: 1.0em;
  		background-color: #f49648;
		  font-family: "Helvetica,Arial,FreeSans";
  		color: #000000;
    }
    #container {
      margin: 0 auto;
      width: 700px;
    }
		h1 { font-size: 3.8em; color: #0b69b7; margin-bottom: 3px; }
		h1 .small { font-size: 0.4em; }
		h1 a { text-decoration: none }
		h2 { font-size: 1.5em; color: #0b69b7; }
    h3 { color: #0b69b7; }
    a { color: #0b69b7; }
    .description { font-size: 1.2em; margin-bottom: 30px; margin-top: 30px; font-style: italic;}
    .download { float: right; }
		pre { background: #000; color: #fff; padding: 15px;}
    hr { border: 0; width: 80%; border-bottom: 1px solid #aaa}
    .footer { text-align:center; padding-top:30px; font-style: italic; }
	</style>
	
</head>

<body>

<H1><u>Container, Inversion of Control, and Dependency Injection</u></H1><br/>
<H2><u>Beans</u></H2>
A Bean is just an object. We call it bean because this particular object obeys some
rules and this rules and the bean's lifecycle are managed entirely by what is called
a container.<br/> 
In the java world, a bean is a POJO (Plan Old Java Object), meaning that
virtually any concrete class definition is a bean. Since the latter also
applies in the php world, we should say that a bean is a "POPO"
(Plain Old PHP Object).

<H3><u>Scopes</u></H3>
The scope of the bean defines its lifecycle (when it is created and when should
be destroyed). The container provides the following options as scopes:
<ul>
  <li><u>Singleton:</u>The container will have a single instance for the bean
  (lazy created), and will returns this instance every time this bean is
  asked for.
  </li>
  <li><u>Prototype:</u>The container will return a new instance every time
  this bean is asked for.
  </li>
</ul>

<H3><u>Bean metadata</u></H3>
<p>
For each managed bean by the container, exists a bean definition, which 
composes all the metadata needed by the container and its extensions to
actually create and modify the bean's behavior.
</p>
<p>
This data is generated, and
modified by "Drivers". Drivers are listeners of one or more events in the lifecycle
of the container and the lifecycle of each bean. Currently, Ding supports 2 
different drivers: "xml" and "annotations".
</p>
<p>
The first one reads and parses a xml
file (normally called beans.xml) and the latter generates metadata from the annotations
found in each of the classes of the project and their methods.
</p>
<p>
 Any number of drivers can be used at any
given time, they are supposed to complement each one's metadata. So for example you may
use an annotation in your class at the same time that is declared (with the same or
different features or properties) in the beans.xml file.
</p>
This metadata includes:

<ul>
  <li><u>Properties:</u>Optional. Properties have also its own metadata (see below).</li>
  <li><u>Constructor arguments:</u>Optional. They almost identical to properties, and have
  their own metadata (see below).</li>
  <li><u>Aspects:</u>Optional. All aspects applied to this bean. Aspects have their own
  metadata (see below).</li>
  <li><u>Name:</u>Mandatory. The bean's name.</li>
  <li><u>Class:</u>Mandatory. The bean's full class name (including namespace, like A\B\Foo.</li>
  <li><u>Scope:</u>Mandatory. The bean's scope. This informs the container how to handle
  the lifecycle of this bean.</li>
  <li><u>Annotations:</u>Optional. All class-level annotations. Annotations have their
  own metadata. (see below).</li>
  <li><u>Init method:</u>Optional. You may declare an optional method to call right after the bean
  is constructed and its properties injected so you can initialize internal stuff.</li>
  <li><u>Shutdown method</u>Optional. You may declare an optional method to call when the container
  is destroyed, so you can cleanup internal stuff.</li>
  <li><u>Method annotations:</u>Optional. All method-level annotations.</li>
  <li><u>Bean dependencies:</u>Optional. Which beans need to be created before creating
  this bean. This has nothing to do with properties that reference other beans
  (those are resolved when creating each property), but with indirect
  dependencies (for instance, bean A depends on bean B which in turns depends
  on bean C, so in order to create bean A, we need to create C and B).</li>
  <li><u>Factory Method:</u>Optional. If specified, will call a static method of Factory
  Class, a method of Factory Method, or a static method of the bean class in
  order to create the bean (instead of using the constructor).</li>
  <li><u>Factory Class:</u>Optional. If specified, informs the container to call
  a static method (see Factory Method) of the given class to create the bean
  instead of using the constructor.</li>
  <li><u>Factory Bean:</u>Optional. Same as factory class, but will use a method for 
  the given bean.</li> 
</ul>

<H4><u>Examples:</u></H4>
<u>Generic bean definition</u>
<p>
For a prototype bean (multiple instances allowed):<br/>
&lt;beans&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;bean id="beanName" class="A\B\C" scope="prototype"/&gt;<br/>
&lt;/beans&gt;<br/>
</p>
<hr/>
<p>
For a singleton bean (only one instance allowed):<br/>
&lt;beans&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;bean id="beanName" class="A\B\C" scope="singleton"/&gt;<br/>
&lt;/beans&gt;<br/>
</p>
All options in the above examples are *MANDATORY*. What follows are examples with
optional arguments:
<hr/>
<p>
This one will first create aBean, bBean, cBean before creating "beanName":<br/>
&lt;beans&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;bean id="beanName" class="A\B\C" scope="prototype" depends-on="aBean, bBean, cBean"/&gt;<br/>
&lt;/beans&gt;<br/>
</p>
<hr/>
<p>
This one will call A\B\C::getInstance() (static method) in order to get a bean:<br/>
&lt;beans&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;bean id="beanName" class="A\B\C" scope="prototype" factory-method="getInstance"/&gt;<br/>
&lt;/beans&gt;<br/>
</p>
<hr/>
<p>
This one will call AnotherClass::getInstance() (static method) in order to get a bean:<br/>
&lt;beans&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;bean id="beanName" class="A\B\C" scope="prototype" factory-class="AnotherClass" factory-method="getInstance"/&gt;<br/>
&lt;/beans&gt;<br/>
</p>
<hr/>
<p>
This one will first create "anotherBean" and then call anotherBean->getInstance() (instance method) in order to get the other bean:<br/>
&lt;beans&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;bean id="beanName" class="A\B\C" scope="prototype" factory-bean="anotherBean" factory-method="getInstance"/&gt;<br/>
&lt;/beans&gt;<br/>
</p>
<hr/>
<p>
This one will call init() as soon as the bean is created and all its properties are injected but before returning the instance to the caller:<br/>
&lt;beans&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;bean id="beanName" class="A\B\C" scope="prototype" init-method="init"/&gt;<br/>
&lt;/beans&gt;<br/>
</p>
<hr/>
<p>
This one will call destroy() when the container is destroyed:<br/>
&lt;beans&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;bean id="beanName" class="A\B\C" scope="prototype" destroy-method="destroy"/&gt;<br/>
&lt;/beans&gt;<br/>
</p>
<hr/>
<H3><u>Constructor arguments types and metadata</u></H3>
The constructor arguments for a bean behave exactly like properties. See the
sections below.
 
<H3><u>Properties types</u></H3>
<ul>
  <li><u>Array:</u>An array has a key (mandatory) and 1 value per key (which in
  turn can be of any type, so you can have arrays inside arrays, etc).</li>
  <li><u>Scalar value:</u>A final value, like a string, an integer, etc.</li>
  <li><u>Bean reference:</u>A string containing the name of another bean defined
  in the container.</li>
  <li><u>Code:</u>PHP code to be eval()'uated by the container.</li>
</ul>

<H3><u>Properties metadata</u></H3>
<ul>
  <li><u>Name:</u>The name of the property. The name is important for setter
injection, i.e: a property called 'name' will be injected calling setName()</li>
  <li><u>Type:</u>See above for properties types</li>
  <li><u>Value:</u>The actual value, whatever the type. The value can also be
  a string like ${some.value}, which resembles java properties. The container will
  notice this and will put the correct value (assuming you passed the right value
  when instantiating the container).</li>
</ul>

<H4><u>Examples:</u></H4>
<p>
Define a scalar property:<br/>
&lt;beans&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;bean id="beanName" class="A\B\C" scope="prototype"&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;property name="someProperty"&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;value&gt;aValue&lt;/value&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/property&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;/bean&gt;<br/>
&lt;/beans&gt;<br/>
</p>
<hr/>
<p>
Define a scalar constructor argument:<br/>
&lt;beans&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;bean id="beanName" class="A\B\C" scope="prototype"&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;constructor-arg&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;value&gt;aValue&lt;/value&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/constructor-arg&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;/bean&gt;<br/>
&lt;/beans&gt;<br/>
</p>
<hr/>
<p>
Mixing both:<br/>
&lt;beans&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;bean id="beanName" class="A\B\C" scope="prototype"&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;constructor-arg&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;value&gt;aValue&lt;/value&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/constructor-arg&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;property name="someProperty"&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;value&gt;aValue&lt;/value&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/property&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;/bean&gt;<br/>
&lt;/beans&gt;<br/>
</p>
<hr/>
<H4>The following examples also apply to constructor arguments</H4>
<p>
Define a scalar property with a container property:<br/>
&lt;beans&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;bean id="beanName" class="A\B\C" scope="prototype"&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;property name="someProperty"&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;value&gt;${some.value}&lt;/value&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/property&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;/bean&gt;<br/>
&lt;/beans&gt;<br/>
</p>
<hr/>
<p>
Define a reference to another bean as a property:<br/>
&lt;beans&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;bean id="beanName" class="A\B\C" scope="prototype"&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;property name="someProperty"&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;ref bean="otherBean"/&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/property&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;/bean&gt;<br/>
&lt;/beans&gt;<br/>
</p>
<hr/>
<p>
Define a property as code to be evaluated:<br/>
&lt;beans&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;bean id="beanName" class="A\B\C" scope="prototype"&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;property name="someProperty"&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;eval&gt;&lt;![CDATA[ return "Some evaluated code"; ]]>&lt;/eval&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/property&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;/bean&gt;<br/>
&lt;/beans&gt;<br/>
</p>
<hr/>
<p>
Define an array as a property:<br/>
&lt;beans&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;bean id="beanName" class="A\B\C" scope="prototype"&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;property name="someProperty"&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;array&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;entry key="0"&gt;&lt;ref bean="otherBean"/&gt;&lt;/entry&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;entry key="1"&gt;&lt;value&gt;aValue&lt;/value&gt;&lt;/entry&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;entry key="2"&gt;&lt;eval&gt;&lt;![CDATA[ return "Some evaluated code"; ]]>&lt;/eval&gt;&lt;/entry&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;entry key="3"&gt;&lt;array&gt;&lt;entry key="other"&gt;&lt;value&gt;${aValue}&lt;/value&gt;&lt;/entry&gt;&lt;/array&gt;&lt;/entry&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/array&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/property&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;/bean&gt;<br/>
&lt;/beans&gt;<br/>
</p>
<hr/>
<H3><u>Annotations metadata</u></H3>
<ul>
  <li><u>Name:</u>The name of the annotation (i.e: @InitMethod).
  <li><u>Arguments:</u>The annotations arguments. For example @InitMethod(method=xxx)
  will result in an annotation named InitMethod with an argument 'method' having the
  value 'xxx'.</li>
</ul>


<H2><u>Container</u></H2>

The container is a factory of beans. It constructs an instance of a bean using the
metadata associated with it (and its subparts, like properties, annotations, etc).

A bean may have properties and/or constructor arguments that need to be "injected"
at some point during the bean's lifecycle. The container supports the following methods
for injecting data into the beans:
<ul>
  <li><u>Setter injection:</u>
  <li><u>Constructor injection:</u>
</ul>

<H3><u>Container managed annotations</u></H3>
<ul>
  <li><u>@InitMethod</u></li>
  <li><u>@DestroyMethod</u></li>
</ul>
</body>
</html>