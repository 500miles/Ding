<html>
    <head>
        <script
            type="text/javascript"
            src="../../../js/jquery-1.4.2.min.js">
        </script>
        <script
            type="text/javascript"
            src="../../../syntax_highlighter/scripts/shCore.js">
        </script>
        <script
            type="text/javascript"
            src="../../../syntax_highlighter/scripts/shBrushJScript.js">
        </script>
        <script
            type="text/javascript"
            src="../../../syntax_highlighter/scripts/shBrushPhp.js">
        </script>
        <script
            type="text/javascript"
            src="../../../syntax_highlighter/scripts/shBrushXml.js">
        </script>
        <link
            href="../../../syntax_highlighter/styles/shCore.css" rel="stylesheet"
            type="text/css"
        />
        <link
            href="../../../syntax_highlighter/styles/shCoreEclipse.css"
            rel="stylesheet" type="text/css"
        />
        <link
            href="../../../syntax_highlighter/styles/shThemeWordpress.css"
            rel="stylesheet" type="text/css"
        />
    </head>
    <body>
        <pre class="brush: php">&lt;?php
/**
 * Tcp Server helper. You need to declare(ticks) in your own source code or
 * manually call process() in an infinite loop from your software.
 *
 * PHP Version 5
 *
 * @category   Ding
 * @package    Helpers
 * @subpackage Tcp
 * @author     Marcelo Gornstein &lt;marcelog@gmail.com&gt;
 * @license    http://marcelog.github.com/ Apache License 2.0
 * @link       http://marcelog.github.com/
 *
 * Copyright 2011 Marcelo Gornstein &lt;marcelog@gmail.com&gt;
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
namespace Ding\Helpers\Tcp;

use Ding\Helpers\Tcp\Exception\TcpException;

/**
 * Tcp Server helper. You need to declare(ticks) in your own source code or
 * manually call process() in an infinite loop from your software.
 *
 * PHP Version 5
 *
 * @category   Ding
 * @package    Helpers
 * @subpackage Tcp
 * @author     Marcelo Gornstein &lt;marcelog@gmail.com&gt;
 * @license    http://marcelog.github.com/ Apache License 2.0
 * @link       http://marcelog.github.com/
 */
class TcpServerHelper
{
    /**
     * Target port
     * @var integer
     */
    private $_port;

    /**
     * Target host or ip address.
     * @var string
     */
    private $_address;

    /**
     * Socket resource.
     * @var socket
     */
    private $_socket;

    /**
     * Handler for this connection (your class).
     * @var ITcpClientHandler
     */
    private $_handler;

    /**
     * Minimum needed bytes in the socket before calling data() on the handler.
     * @var integer
     */
    private $_readLen;

    /**
     * Read timeout in milliseconds.
     * @var integer
     */
    private $_rTo;

    /**
     * Maximum number of connections to handle at any given time.
     * @var integer
     */
    private $_backlog;

    /**
     * Internal flag in order to know if the socket is connected.
     * @var boolean
     */
    private $_open;

    /**
     * Holds peers sockets.
     * @var socket[]
     */
    private $_peersSockets;
    /**
     * Holds peers.
     * @var \Ding\Helpers\Tcp\TcpPeer[]
     */
    private $_peers;

    /**
     * Holds last time for received data for each peer.
     * @var float[]
     */
    private $_peersLastDataReceived;

    /**
     * Wether to reuse or not the binding of the socket.
     * @var boolean
     */
    private $_reuse;

    /**
     * Call this to close the server.
     *
     * @return void
     */
    public function close()
    {
        $this-&gt;_open = false;
        $this-&gt;_peers = array();
        $this-&gt;_peersSockets = array();
        $this-&gt;_peersLastDataReceived = array();
        $this-&gt;_handler-&gt;close();
        socket_close($this-&gt;_socket);
        $this-&gt;_socket = false;
    }


    /**
     * Call this to bind the socket and start listening for connections.
     * Will also set the socket non blocking.
     *
     * @throws TcpException
     * @return void
     */
    public function open()
    {
        $this-&gt;_open = false;
        $this-&gt;_handler-&gt;beforeOpen();
        $this-&gt;_socket = socket_create(AF_INET, SOCK_STREAM, SOL_TCP);
        if ($this-&gt;_socket === false) {
            throw new TcpException(
            	'Error opening socket: ' . socket_strerror(socket_last_error())
            );
        }
        if ($this-&gt;_reuse) {
            socket_set_option ($this-&gt;_socket, SOL_SOCKET, SO_REUSEADDR, 1);
        }
        if (!@socket_bind($this-&gt;_socket, $this-&gt;_address, $this-&gt;_port)) {
            $error = socket_strerror(socket_last_error($this-&gt;_socket));
            socket_close($this-&gt;_socket);
            $this-&gt;_socket = false;
            throw new TcpException('Error binding socket: ' . $error);
        }
        socket_set_nonblock($this-&gt;_socket);
        $this-&gt;_handler-&gt;beforeListen();
        if (!socket_listen($this-&gt;_socket, $this-&gt;_backlog)) {
            $error = socket_strerror(socket_last_error($this-&gt;_socket));
            socket_close($this-&gt;_socket);
            $this-&gt;_socket = false;
            throw new TcpException('Error listening socket: ' . $error);
        }
        $this-&gt;_open = true;
    }

    /**
     * From php examples. Returns time including millseconds.
     *
     * @todo duplicated code, where can this go?
     * @return float
     */
    protected function getMicrotime()
    {
        list($usec, $sec) = explode(&quot; &quot;, microtime());
        return ((float)$usec + (float)$sec);
    }

    /**
     * After disconnecting a peer, this will release all the associated
     * information.
     *
     * @return void
     */
    private function _freePeer(\Ding\Helpers\Tcp\TcpPeer $peer)
    {
        $peerName = $peer-&gt;getName();
        unset($this-&gt;_peers[$peerName]);
        unset($this-&gt;_peersSockets[$peerName]);
        unset($this-&gt;_peersLastDataReceived[$peerName]);
    }
    /**
     * This will process activity in all peers. Called from process().
     *
     * @return void
     */
    public function processPeers()
    {
        // Control peers.
        if (count($this-&gt;_peers) &lt; 1) {
            return;
        }
        $now = $this-&gt;getMicrotime();
        foreach ($this-&gt;_peers as $peerName =&gt; $peer) {
            if (!$peer-&gt;hasActivity()) {
                continue;
            }
            $buffer = '';
            $len = 1;
            $len = $peer-&gt;read($buffer, $len, true);
            if ($len &gt; 0) {
                if ($len &gt;= $this-&gt;_readLen) {
                    $this-&gt;_handler-&gt;handleData($peer);
                    $this-&gt;_peersLastDataReceived[$peerName] = $now;
                }
            } else {
                $peer-&gt;disconnect();
                $this-&gt;_freePeer($peer);
                $this-&gt;_handler-&gt;disconnect($peer);
            }
        }
        foreach ($this-&gt;_peers as $peerName =&gt; $peer) {
            $peerTime = $this-&gt;_peersLastDataReceived[$peerName];
            if (($now - $peerTime) &gt; $this-&gt;_rTo) {
                if ($this-&gt;_rTo &gt; 0) {
                    $peer-&gt;disconnect();
                    $this-&gt;_freePeer($peer);
                    $this-&gt;_handler-&gt;readTimeout($peer);
                }
                $this-&gt;_peersLastDataReceived[$peerName] = $now;
            }
        }
    }
    /**
     * Main reading loop. Call this in your own infinite loop or declare(ticks)
     * in your software. This routine will call your server handler when there
     * is data available to read, new connections, or timeouts. Will always
     * detect when the other side closed the connection.
     *
     * @return void
     */
    public function process()
    {
        if ($this-&gt;_socket === false || !$this-&gt;_open) {
            return;
        }
        // Control server.
        $read = array($this-&gt;_socket);
        $write = null;
        $ex = null;
        $result = @socket_select($read, $write, $ex, 0, 1);
        if ($result === false) {
            throw new TcpException(
            	'Error selecting from socket: '
                . socket_strerror(socket_last_error($this-&gt;_socket))
            );
        }
        if ($result &gt; 0) {
            if (in_array($this-&gt;_socket, $read)) {
                $newSocket = socket_accept($this-&gt;_socket);
                if ($newSocket !== false) {
                    $address = '';
                    $port = 0;
                    socket_getpeername($newSocket, $address, $port);
                    $peerObject = new \Ding\Helpers\Tcp\TcpPeer($address, $port, $newSocket);
                    $peername = $peerObject-&gt;getName();
                    $this-&gt;_peers[$peername] = $peerObject;
                    $this-&gt;_peersSockets[$peername] = $newSocket;
                    $this-&gt;_peersLastDataReceived[$peername] = $this-&gt;getMicrotime();
                    $this-&gt;_handler-&gt;handleConnection($peerObject);
                }
            }
        }
        $this-&gt;processPeers();
    }

    /**
     * Minimum needed bytes available in the socket before calling data() on the
     * server handler.
     *
     * @param integer $rLen Minimum data needed in socket.
     *
     * @return void
     */
    public function setReadMinLength($rLen)
    {
        $this-&gt;_readLen = intval($rLen);
    }

    /**
     * Sets the read timeout in milliseconds. 0 to disable.
     *
     * @param integer $rTo Read timeout.
     *
     * @return void
     */
    public function setReadTimeout($rTo)
    {
        $this-&gt;_rTo = (float)($rTo / 1000);
    }

    /**
     * Sets maximum number of connections.
     *
     * @param integer $backlog Max number of connections to handle.
     *
     * @return void
     */
    public function setBacklog($backlog)
    {
        $this-&gt;_backlog = intval($backlog);
    }

    /**
     * Sets the tcp server handler.
     *
     * @param ITcpServerHandler $handler Server handler to use for callbacks.
     *
     * @return void
     */
    public function setHandler(ITcpServerHandler $handler)
    {
        $this-&gt;_handler = $handler;
    }

    /**
     * Sets server port.
     *
     * @param integer $port Server port.
     *
     * @return void
     */
    public function setPort($port)
    {
        $this-&gt;_port = $port;
    }

    /**
     * Sets server host or ip address.
     *
     * @param string $address Server host or ip address.
     *
     * @return void
     */
    public function setAddress($address)
    {
        $this-&gt;_address = $address;
    }

    /**
     * Sets wether to reuse or not the socket bind.
     *
     * @param boolean $reuse True to reuse the binding address.
     *
     * @return void
     */
    public function setReuse($reuse)
    {
        $this-&gt;_reuse = $reuse;
    }

    /**
     * Constructor. Not much to see here. Will register a tick function(),
     * process().
     *
     * @return void
     */
    public function __construct()
    {
        $this-&gt;_handler = false;
        $this-&gt;_socket = false;
        $this-&gt;_address = false;
        $this-&gt;_port = false;
        $this-&gt;_backlog = 0;
        $this-&gt;_rTo = 0;
        $this-&gt;_rLen = 1;
        $this-&gt;_connected = false;
        $this-&gt;_peers = array();
        $this-&gt;_peersSockets = array();
        $this-&gt;_peersLastDataReceived = array();
        $this-&gt;_reuse = false;
        register_tick_function(array($this, 'process'));
    }
}</pre>
        <script type="text/javascript">
             SyntaxHighlighter.all()
             jQuery('.gutter div').each(function(key, data){
                jQuery(data).prepend('<a name="L'+jQuery(data).text()+'"/>');
             });
        </script>
    </body>
</html>