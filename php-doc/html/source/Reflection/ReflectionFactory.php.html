<html>
    <head>
        <script
            type="text/javascript"
            src="../../js/jquery-1.4.2.min.js">
        </script>
        <script
            type="text/javascript"
            src="../../syntax_highlighter/scripts/shCore.js">
        </script>
        <script
            type="text/javascript"
            src="../../syntax_highlighter/scripts/shBrushJScript.js">
        </script>
        <script
            type="text/javascript"
            src="../../syntax_highlighter/scripts/shBrushPhp.js">
        </script>
        <script
            type="text/javascript"
            src="../../syntax_highlighter/scripts/shBrushXml.js">
        </script>
        <link
            href="../../syntax_highlighter/styles/shCore.css" rel="stylesheet"
            type="text/css"
        />
        <link
            href="../../syntax_highlighter/styles/shCoreEclipse.css"
            rel="stylesheet" type="text/css"
        />
        <link
            href="../../syntax_highlighter/styles/shThemeWordpress.css"
            rel="stylesheet" type="text/css"
        />
    </head>
    <body>
        <pre class="brush: php">&lt;?php
/**
 * Internal reflection manager.
 *
 * PHP Version 5
 *
 * @category Ding
 * @package  Reflection
 * @author   Marcelo Gornstein &lt;marcelog@gmail.com&gt;
 * @license  http://marcelog.github.com/ Apache License 2.0
 * @link     http://marcelog.github.com/
 *
 * Copyright 2011 Marcelo Gornstein &lt;marcelog@gmail.com&gt;
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
namespace Ding\Reflection;

use Ding\Annotation\Collection;
use Ding\Annotation\Parser;
use Ding\Cache\ICache;

/**
 * Internal reflection manager.
 *
 * PHP Version 5
 *
 * @category Ding
 * @package  Reflection
 * @author   Marcelo Gornstein &lt;marcelog@gmail.com&gt;
 * @license  http://marcelog.github.com/ Apache License 2.0
 * @link     http://marcelog.github.com/
 */
class ReflectionFactory implements IReflectionFactory
{
    /**
     * Cache reflection classes instantiated so far.
     * @var ReflectionClass[]
     */
    private $_reflectionClasses = array();
    /**
     * A map where the key is the class, and the value is an array with the
     * 'class annotations and its annotated methods.
     * @var string[]
     */
    private $_annotatedClasses = array();
    private $_annotatedMethods = array();
    private $_annotatedProperties = array();

    /**
     * A map where the key is the annotations, and the value is an array with
     * all the classes (not their methods) with this annotation.
     * @var string[]
     */
    private $_classesAnnotated = array();

    /**
     * Reflection methods, indexed by class.
     * @var string[]
     */
    private $_reflectionMethods = array();

    private $_reflectionProperties = array();

    /**
     * Wether to use annotations or not.
     * @var boolean
     */
    private $_withAnnotations = false;

    /**
     * Annotations cache.
     * @var ICache
     */
    private $_cache = false;

    private $_annotationParser;

    public function setAnnotationParser(Parser $parser)
    {
        $this-&gt;_annotationParser = $parser;
    }

    /**
     * (non-PHPdoc)
     * @see Ding\Reflection.IReflectionFactory::getClassesFromCode()
     */
    public function getClassesFromCode($code)
    {
        // Taken from: http://stackoverflow.com/questions/928928/determining-what-classes-are-defined-in-a-php-class-file
        $classes = array();
        $tokens = token_get_all($code);
        $count = count($tokens);
        $namespace = '';
        for ($i = 0; $i &lt; $count; $i++) {
            if (
                $tokens[$i][0] == T_CLASS
                &amp;&amp; $tokens[$i + 1][0] == T_WHITESPACE
                &amp;&amp; $tokens[$i + 2][0] == T_STRING
            ) {
                $class_name = $tokens[$i + 2][1];
                $classes[] = empty($namespace) ? $class_name : $namespace . &quot;\\&quot; . $class_name;
                $i += 2;
            } else if ($tokens[$i][0] === T_NAMESPACE) {
                for(; $tokens[$i][0] !== T_STRING; $i++);
                $namespace = $tokens[$i][1];
                for($i++; $tokens[$i][0] !== ';'; $i++) {
                        for(; $tokens[$i][0] !== T_STRING; $i++);
                        $namespace .= &quot;\\&quot; . $tokens[$i][1];
                }
            }
        }
        return $classes;
   }
    /**
     * Returns all files elegible for scanning for classes.
     *
     * @param string $path Absolute path to a directory or filename.
     *
     * @return string[]
     */
    private function _getCandidateFilesForClassScanning($path)
    {
        $cacheKey = &quot;$path.candidatefiles&quot;;
        $result = false;
        $files = $this-&gt;_cache-&gt;fetch($cacheKey, $result);
        if ($result === true) {
            return $files;
        }
        $files = array();
        if (is_dir($path)) {
            foreach (scandir($path) as $entry) {
                if ($entry == '.' || $entry == '..') {
                    continue;
                }
                $entry = &quot;$path/$entry&quot;;
                foreach ($this-&gt;_getCandidateFilesForClassScanning($entry) as $file) {
                    $files[] = $file;
                }
            }
        } else if ($this-&gt;_isScannable($path)) {
            $files[] = realpath($path);
        }
        $this-&gt;_cache-&gt;store($cacheKey, $files);
        return $files;
    }

    /**
     * (non-PHPdoc)
     * @see Ding\Reflection.IReflectionFactory::getClassesFromFile()
     */
    public function getClassesFromFile($file)
    {
        $cacheKey = &quot;$file.classesinfile&quot;;
        $result = false;
        $classes = $this-&gt;_cache-&gt;fetch($cacheKey, $result);
        if ($result === true) {
            return $classes;
        }
        $classes = $this-&gt;getClassesFromCode(@file_get_contents($file));
        $this-&gt;_cache-&gt;store($cacheKey, $classes);
        return $classes;
    }

    /**
     * (non-PHPdoc)
     * @see Ding\Reflection.IReflectionFactory::getClassesFromDirectory()
     */
    public function getClassesFromDirectory($dir)
    {
        $cacheKey = &quot;$dir.classesindir&quot;;
        $result = false;
        $classes = $this-&gt;_cache-&gt;fetch($cacheKey, $result);
        if ($result === true) {
            return $classes;
        }
        $classes = array();
        foreach ($this-&gt;_getCandidateFilesForClassScanning($dir) as $file) {
            $classes[$file] = $this-&gt;getClassesFromFile($file);
        }
        $this-&gt;_cache-&gt;store($cacheKey, $classes);
        return $classes;
    }
    /**
     * Returns true if the given filesystem entry is interesting to scan.
     *
     * @param string $path Filesystem entry.
     */
    private function _isScannable($path)
    {
        $extensionPos = strrpos($path, '.');
        if ($extensionPos === false) {
            return false;
        }
        if (substr($path, $extensionPos, 4) != '.php') {
            return false;
        }
        return true;
    }

    /**
     * (non-PHPdoc)
     * @see Ding\Reflection.IReflectionFactory::getClassesByAnnotation()
     */
    public function getClassesByAnnotation($annotation)
    {
        if (!$this-&gt;_withAnnotations) {
            return array();
        }
        if (isset($this-&gt;_classesAnnotated[$annotation])) {
            return $this-&gt;_classesAnnotated[$annotation];
        }
        $cacheKey = $annotation . '.classbyannotations';
        $result = false;
        $classes = $this-&gt;_cache-&gt;fetch($cacheKey, $result);
        if ($result === true) {
            $this-&gt;_classesAnnotated[$annotation] = $classes[$annotation];
            return $this-&gt;_classesAnnotated[$annotation];
        }
        return array();
    }

    /**
     * (non-PHPdoc)
     * @see Ding\Reflection.IReflectionFactory::getMethodAnnotations()
     */
    public function getMethodAnnotations($class, $method)
    {
        if (!$this-&gt;_withAnnotations) {
            return array();
        }
        $key = $class . $method;
        if (isset($this-&gt;_annotatedMethods[$key])) {
            return $this-&gt;_annotatedMethods[$key];
        }
        $cacheKey = $key . '.methodannotations';
        $result = false;
        $annotations = $this-&gt;_cache-&gt;fetch($cacheKey, $result);
        if ($result === true) {
            $this-&gt;_annotatedMethods[$key] = $annotations;
            return $annotations;
        }
        $rMethod = $this-&gt;getMethod($class, $method);
        $annotations = $this-&gt;_annotationParser-&gt;parse($rMethod-&gt;getDocComment());
        $this-&gt;_cache-&gt;store($cacheKey, $annotations);
        return $annotations;
    }

    /**
     * (non-PHPdoc)
     * @see Ding\Reflection.IReflectionFactory::getPropertyAnnotations()
     */
    public function getPropertyAnnotations($class, $property)
    {
        if (!$this-&gt;_withAnnotations) {
            return array();
        }
        $key = $class . $property;
        if (isset($this-&gt;_annotatedProperties[$key])) {
            return $this-&gt;_annotatedProperties[$key];
        }
        $cacheKey = $key . '.propertyannotations';
        $result = false;
        $annotations = $this-&gt;_cache-&gt;fetch($cacheKey, $result);
        if ($result === true) {
            $this-&gt;_annotatedProperties[$key] = $annotations;
            return $annotations;
        }
        $rProperty = $this-&gt;getProperty($class, $property);
        $annotations = $this-&gt;_annotationParser-&gt;parse($rProperty-&gt;getDocComment());
        $this-&gt;_cache-&gt;store($cacheKey, $annotations);
        return $annotations;
    }

    private function _populateClassesPerAnnotations($class, Collection $annotations)
    {
        foreach ($annotations-&gt;getAll() as $name =&gt; $annotation) {
            $cacheKey = $name . '.classbyannotations';
            if (!isset($this-&gt;_classesAnnotated[$name])) {
                $this-&gt;_classesAnnotated[$name] = array();
            }
            $this-&gt;_classesAnnotated[$name][$class] = $class;
            $this-&gt;_cache-&gt;store($cacheKey, $this-&gt;_classesAnnotated);
        }
    }
    /**
     * (non-PHPdoc)
     * @see Ding\Reflection.IReflectionFactory::getClassAnnotations()
     */
    public function getClassAnnotations($class)
    {
        if (!$this-&gt;_withAnnotations) {
            return array();
        }
        if (isset($this-&gt;_annotatedClasses[$class])) {
            return $this-&gt;_annotatedClasses[$class];
        }
        $cacheKey = $class . '.classannotations';
        $result = false;
        $annotations = $this-&gt;_cache-&gt;fetch($cacheKey, $result);
        if ($result === true) {
            $this-&gt;_annotatedClasses[$class] = $annotations;
            return $annotations;
        }
        $this-&gt;_annotatedClasses[$class] = array();
        $rClass = $this-&gt;getClass($class);
        $annotations = $this-&gt;_annotationParser-&gt;parse($rClass-&gt;getDocComment());
        $this-&gt;_populateClassesPerAnnotations($class, $annotations);
        $this-&gt;_annotatedClasses[$class] = $annotations;
        $this-&gt;_cache-&gt;store($cacheKey, $annotations);
        return $annotations;
    }

    /**
     * (non-PHPdoc)
     * @see Ding\Reflection.IReflectionFactory::getClass()
     */
    public function getClass($class)
    {
        if (isset($this-&gt;_reflectionClasses[$class])) {
            return $this-&gt;_reflectionClasses[$class];
        }
        $this-&gt;_reflectionClasses[$class] = new \ReflectionClass($class);
        return $this-&gt;_reflectionClasses[$class];
    }

    /**
     * (non-PHPdoc)
     * @see Ding\Reflection.IReflectionFactory::getMethod()
     */
    public function getMethod($class, $method)
    {
        if (isset($this-&gt;_reflectionMethods[$class][$method])) {
            return $this-&gt;_reflectionMethods[$class][$method];
        }
        if (!isset($this-&gt;_reflectionMethods[$class])) {
            $this-&gt;_reflectionMethods[$class] = array();
        }
        $this-&gt;_reflectionMethods[$class][$method] = new \ReflectionMethod($class, $method);
        return $this-&gt;_reflectionMethods[$class][$method];
    }

    /**
     * (non-PHPdoc)
     * @see Ding\Reflection.IReflectionFactory::getProperty()
     */
    public function getProperty($class, $property)
    {
        if (isset($this-&gt;_reflectionProperties[$class][$property])) {
            return $this-&gt;_reflectionProperties[$class][$property];
        }
        if (!isset($this-&gt;_reflectionProperties[$class])) {
            $this-&gt;_reflectionProperties[$class] = array();
        }
        $this-&gt;_reflectionProperties[$class][$property] = new \ReflectionProperty($class, $property);
        return $this-&gt;_reflectionProperties[$class][$property];
    }

    public function setCache(ICache $cache)
    {
        $this-&gt;_cache = $cache;
    }

    public function __construct($withAnnotations)
    {
        $this-&gt;_withAnnotations = $withAnnotations;
    }

}
</pre>
        <script type="text/javascript">
             SyntaxHighlighter.all()
             jQuery('.gutter div').each(function(key, data){
                jQuery(data).prepend('<a name="L'+jQuery(data).text()+'"/>');
             });
        </script>
    </body>
</html>